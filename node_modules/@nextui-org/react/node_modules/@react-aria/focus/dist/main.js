var $7qnVn$react = require("react");
var $7qnVn$reactariautils = require("@react-aria/utils");
var $7qnVn$reactariainteractions = require("@react-aria/interactions");
var $7qnVn$clsx = require("clsx");

function $parcel$exportWildcard(dest, source) {
  Object.keys(source).forEach(function(key) {
    if (key === 'default' || key === '__esModule' || dest.hasOwnProperty(key)) {
      return;
    }

    Object.defineProperty(dest, key, {
      enumerable: true,
      get: function get() {
        return source[key];
      }
    });
  });

  return dest;
}
function $parcel$interopDefault(a) {
  return a && a.__esModule ? a.default : a;
}
function $parcel$export(e, n, v, s) {
  Object.defineProperty(e, n, {get: v, set: s, enumerable: true, configurable: true});
}
var $4e07e9e0e9f6e0b8$exports = {};

$parcel$export($4e07e9e0e9f6e0b8$exports, "FocusScope", () => $4e07e9e0e9f6e0b8$export$20e40289641fbbb6);
$parcel$export($4e07e9e0e9f6e0b8$exports, "useFocusManager", () => $4e07e9e0e9f6e0b8$export$10c5169755ce7bd7);
$parcel$export($4e07e9e0e9f6e0b8$exports, "getFocusableTreeWalker", () => $4e07e9e0e9f6e0b8$export$2d6ec8fc375ceafa);
$parcel$export($4e07e9e0e9f6e0b8$exports, "createFocusManager", () => $4e07e9e0e9f6e0b8$export$c5251b9e124bf29);
var $a424ea782c64243d$exports = {};

$parcel$export($a424ea782c64243d$exports, "focusSafely", () => $a424ea782c64243d$export$80f3e147d781571c);


function $a424ea782c64243d$export$80f3e147d781571c(element) {
    // If the user is interacting with a virtual cursor, e.g. screen reader, then
    // wait until after any animated transitions that are currently occurring on
    // the page before shifting focus. This avoids issues with VoiceOver on iOS
    // causing the page to scroll when moving focus if the element is transitioning
    // from off the screen.
    if ($7qnVn$reactariainteractions.getInteractionModality() === 'virtual') {
        let lastFocusedElement = document.activeElement;
        $7qnVn$reactariautils.runAfterTransition(()=>{
            // If focus did not move and the element is still in the document, focus it.
            if (document.activeElement === lastFocusedElement && document.contains(element)) $7qnVn$reactariautils.focusWithoutScrolling(element);
        });
    } else $7qnVn$reactariautils.focusWithoutScrolling(element);
}


/*
 * Copyright 2021 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ function $9793aa05cd766621$var$isStyleVisible(element) {
    if (!(element instanceof HTMLElement) && !(element instanceof SVGElement)) return false;
    let { display: display , visibility: visibility  } = element.style;
    let isVisible = display !== 'none' && visibility !== 'hidden' && visibility !== 'collapse';
    if (isVisible) {
        const { getComputedStyle: getComputedStyle  } = element.ownerDocument.defaultView;
        let { display: computedDisplay , visibility: computedVisibility  } = getComputedStyle(element);
        isVisible = computedDisplay !== 'none' && computedVisibility !== 'hidden' && computedVisibility !== 'collapse';
    }
    return isVisible;
}
function $9793aa05cd766621$var$isAttributeVisible(element, childElement) {
    return !element.hasAttribute('hidden') && (element.nodeName === 'DETAILS' && childElement && childElement.nodeName !== 'SUMMARY' ? element.hasAttribute('open') : true);
}
function $9793aa05cd766621$export$e989c0fffaa6b27a(element, childElement) {
    return element.nodeName !== '#comment' && $9793aa05cd766621$var$isStyleVisible(element) && $9793aa05cd766621$var$isAttributeVisible(element, childElement) && (!element.parentElement || $9793aa05cd766621$export$e989c0fffaa6b27a(element.parentElement, element));
}




const $4e07e9e0e9f6e0b8$var$FocusContext = /*#__PURE__*/ ($parcel$interopDefault($7qnVn$react)).createContext(null);
let $4e07e9e0e9f6e0b8$var$activeScope = null;
let $4e07e9e0e9f6e0b8$var$scopes = new Map();
function $4e07e9e0e9f6e0b8$export$20e40289641fbbb6(props) {
    let { children: children , contain: contain , restoreFocus: restoreFocus , autoFocus: autoFocus  } = props;
    let startRef = $7qnVn$react.useRef();
    let endRef = $7qnVn$react.useRef();
    let scopeRef = $7qnVn$react.useRef([]);
    let ctx = $7qnVn$react.useContext($4e07e9e0e9f6e0b8$var$FocusContext);
    let parentScope = ctx?.scopeRef;
    $7qnVn$reactariautils.useLayoutEffect(()=>{
        // Find all rendered nodes between the sentinels and add them to the scope.
        let node = startRef.current.nextSibling;
        let nodes = [];
        while(node && node !== endRef.current){
            nodes.push(node);
            node = node.nextSibling;
        }
        scopeRef.current = nodes;
    }, [
        children,
        parentScope
    ]);
    $7qnVn$reactariautils.useLayoutEffect(()=>{
        $4e07e9e0e9f6e0b8$var$scopes.set(scopeRef, parentScope);
        return ()=>{
            // Restore the active scope on unmount if this scope or a descendant scope is active.
            // Parent effect cleanups run before children, so we need to check if the
            // parent scope actually still exists before restoring the active scope to it.
            if ((scopeRef === $4e07e9e0e9f6e0b8$var$activeScope || $4e07e9e0e9f6e0b8$var$isAncestorScope(scopeRef, $4e07e9e0e9f6e0b8$var$activeScope)) && (!parentScope || $4e07e9e0e9f6e0b8$var$scopes.has(parentScope))) $4e07e9e0e9f6e0b8$var$activeScope = parentScope;
            $4e07e9e0e9f6e0b8$var$scopes.delete(scopeRef);
        };
    }, [
        scopeRef,
        parentScope
    ]);
    $4e07e9e0e9f6e0b8$var$useFocusContainment(scopeRef, contain);
    $4e07e9e0e9f6e0b8$var$useRestoreFocus(scopeRef, restoreFocus, contain);
    $4e07e9e0e9f6e0b8$var$useAutoFocus(scopeRef, autoFocus);
    let focusManager = $4e07e9e0e9f6e0b8$var$createFocusManagerForScope(scopeRef);
    return(/*#__PURE__*/ ($parcel$interopDefault($7qnVn$react)).createElement($4e07e9e0e9f6e0b8$var$FocusContext.Provider, {
        value: {
            scopeRef: scopeRef,
            focusManager: focusManager
        }
    }, /*#__PURE__*/ ($parcel$interopDefault($7qnVn$react)).createElement("span", {
        "data-focus-scope-start": true,
        hidden: true,
        ref: startRef
    }), children, /*#__PURE__*/ ($parcel$interopDefault($7qnVn$react)).createElement("span", {
        "data-focus-scope-end": true,
        hidden: true,
        ref: endRef
    })));
}
function $4e07e9e0e9f6e0b8$export$10c5169755ce7bd7() {
    return $7qnVn$react.useContext($4e07e9e0e9f6e0b8$var$FocusContext)?.focusManager;
}
function $4e07e9e0e9f6e0b8$var$createFocusManagerForScope(scopeRef) {
    return {
        focusNext (opts = {
        }) {
            let scope = scopeRef.current;
            let { from: from , tabbable: tabbable , wrap: wrap  } = opts;
            let node = from || document.activeElement;
            let sentinel = scope[0].previousElementSibling;
            let walker = $4e07e9e0e9f6e0b8$export$2d6ec8fc375ceafa($4e07e9e0e9f6e0b8$var$getScopeRoot(scope), {
                tabbable: tabbable
            }, scope);
            walker.currentNode = $4e07e9e0e9f6e0b8$var$isElementInScope(node, scope) ? node : sentinel;
            let nextNode = walker.nextNode();
            if (!nextNode && wrap) {
                walker.currentNode = sentinel;
                nextNode = walker.nextNode();
            }
            if (nextNode) $4e07e9e0e9f6e0b8$var$focusElement(nextNode, true);
            return nextNode;
        },
        focusPrevious (opts = {
        }) {
            let scope = scopeRef.current;
            let { from: from , tabbable: tabbable , wrap: wrap  } = opts;
            let node = from || document.activeElement;
            let sentinel = scope[scope.length - 1].nextElementSibling;
            let walker = $4e07e9e0e9f6e0b8$export$2d6ec8fc375ceafa($4e07e9e0e9f6e0b8$var$getScopeRoot(scope), {
                tabbable: tabbable
            }, scope);
            walker.currentNode = $4e07e9e0e9f6e0b8$var$isElementInScope(node, scope) ? node : sentinel;
            let previousNode = walker.previousNode();
            if (!previousNode && wrap) {
                walker.currentNode = sentinel;
                previousNode = walker.previousNode();
            }
            if (previousNode) $4e07e9e0e9f6e0b8$var$focusElement(previousNode, true);
            return previousNode;
        },
        focusFirst (opts = {
        }) {
            let scope = scopeRef.current;
            let { tabbable: tabbable  } = opts;
            let walker = $4e07e9e0e9f6e0b8$export$2d6ec8fc375ceafa($4e07e9e0e9f6e0b8$var$getScopeRoot(scope), {
                tabbable: tabbable
            }, scope);
            walker.currentNode = scope[0].previousElementSibling;
            let nextNode = walker.nextNode();
            if (nextNode) $4e07e9e0e9f6e0b8$var$focusElement(nextNode, true);
            return nextNode;
        },
        focusLast (opts = {
        }) {
            let scope = scopeRef.current;
            let { tabbable: tabbable  } = opts;
            let walker = $4e07e9e0e9f6e0b8$export$2d6ec8fc375ceafa($4e07e9e0e9f6e0b8$var$getScopeRoot(scope), {
                tabbable: tabbable
            }, scope);
            walker.currentNode = scope[scope.length - 1].nextElementSibling;
            let previousNode = walker.previousNode();
            if (previousNode) $4e07e9e0e9f6e0b8$var$focusElement(previousNode, true);
            return previousNode;
        }
    };
}
const $4e07e9e0e9f6e0b8$var$focusableElements = [
    'input:not([disabled]):not([type=hidden])',
    'select:not([disabled])',
    'textarea:not([disabled])',
    'button:not([disabled])',
    'a[href]',
    'area[href]',
    'summary',
    'iframe',
    'object',
    'embed',
    'audio[controls]',
    'video[controls]',
    '[contenteditable]'
];
const $4e07e9e0e9f6e0b8$var$FOCUSABLE_ELEMENT_SELECTOR = $4e07e9e0e9f6e0b8$var$focusableElements.join(':not([hidden]),') + ',[tabindex]:not([disabled]):not([hidden])';
$4e07e9e0e9f6e0b8$var$focusableElements.push('[tabindex]:not([tabindex="-1"]):not([disabled])');
const $4e07e9e0e9f6e0b8$var$TABBABLE_ELEMENT_SELECTOR = $4e07e9e0e9f6e0b8$var$focusableElements.join(':not([hidden]):not([tabindex="-1"]),');
function $4e07e9e0e9f6e0b8$var$getScopeRoot(scope) {
    return scope[0].parentElement;
}
function $4e07e9e0e9f6e0b8$var$useFocusContainment(scopeRef, contain) {
    let focusedNode = $7qnVn$react.useRef();
    let raf = $7qnVn$react.useRef(null);
    $7qnVn$reactariautils.useLayoutEffect(()=>{
        let scope1 = scopeRef.current;
        if (!contain) return;
        // Handle the Tab key to contain focus within the scope
        let onKeyDown = (e)=>{
            if (e.key !== 'Tab' || e.altKey || e.ctrlKey || e.metaKey || scopeRef !== $4e07e9e0e9f6e0b8$var$activeScope) return;
            let focusedElement = document.activeElement;
            let scope = scopeRef.current;
            if (!$4e07e9e0e9f6e0b8$var$isElementInScope(focusedElement, scope)) return;
            let walker = $4e07e9e0e9f6e0b8$export$2d6ec8fc375ceafa($4e07e9e0e9f6e0b8$var$getScopeRoot(scope), {
                tabbable: true
            }, scope);
            walker.currentNode = focusedElement;
            let nextElement = e.shiftKey ? walker.previousNode() : walker.nextNode();
            if (!nextElement) {
                walker.currentNode = e.shiftKey ? scope[scope.length - 1].nextElementSibling : scope[0].previousElementSibling;
                nextElement = e.shiftKey ? walker.previousNode() : walker.nextNode();
            }
            e.preventDefault();
            if (nextElement) $4e07e9e0e9f6e0b8$var$focusElement(nextElement, true);
        };
        let onFocus = (e)=>{
            // If focusing an element in a child scope of the currently active scope, the child becomes active.
            // Moving out of the active scope to an ancestor is not allowed.
            if (!$4e07e9e0e9f6e0b8$var$activeScope || $4e07e9e0e9f6e0b8$var$isAncestorScope($4e07e9e0e9f6e0b8$var$activeScope, scopeRef)) {
                $4e07e9e0e9f6e0b8$var$activeScope = scopeRef;
                focusedNode.current = e.target;
            } else if (scopeRef === $4e07e9e0e9f6e0b8$var$activeScope && !$4e07e9e0e9f6e0b8$var$isElementInChildScope(e.target, scopeRef)) {
                // If a focus event occurs outside the active scope (e.g. user tabs from browser location bar),
                // restore focus to the previously focused node or the first tabbable element in the active scope.
                if (focusedNode.current) focusedNode.current.focus();
                else if ($4e07e9e0e9f6e0b8$var$activeScope) $4e07e9e0e9f6e0b8$var$focusFirstInScope($4e07e9e0e9f6e0b8$var$activeScope.current);
            } else if (scopeRef === $4e07e9e0e9f6e0b8$var$activeScope) focusedNode.current = e.target;
        };
        let onBlur = (e)=>{
            // Firefox doesn't shift focus back to the Dialog properly without this
            raf.current = requestAnimationFrame(()=>{
                // Use document.activeElement instead of e.relatedTarget so we can tell if user clicked into iframe
                if (scopeRef === $4e07e9e0e9f6e0b8$var$activeScope && !$4e07e9e0e9f6e0b8$var$isElementInChildScope(document.activeElement, scopeRef)) {
                    $4e07e9e0e9f6e0b8$var$activeScope = scopeRef;
                    focusedNode.current = e.target;
                    focusedNode.current.focus();
                }
            });
        };
        document.addEventListener('keydown', onKeyDown, false);
        document.addEventListener('focusin', onFocus, false);
        scope1.forEach((element)=>element.addEventListener('focusin', onFocus, false)
        );
        scope1.forEach((element)=>element.addEventListener('focusout', onBlur, false)
        );
        return ()=>{
            document.removeEventListener('keydown', onKeyDown, false);
            document.removeEventListener('focusin', onFocus, false);
            scope1.forEach((element)=>element.removeEventListener('focusin', onFocus, false)
            );
            scope1.forEach((element)=>element.removeEventListener('focusout', onBlur, false)
            );
        };
    }, [
        scopeRef,
        contain
    ]);
    // eslint-disable-next-line arrow-body-style
    $7qnVn$react.useEffect(()=>{
        return ()=>cancelAnimationFrame(raf.current)
        ;
    }, [
        raf
    ]);
}
function $4e07e9e0e9f6e0b8$var$isElementInAnyScope(element) {
    for (let scope of $4e07e9e0e9f6e0b8$var$scopes.keys()){
        if ($4e07e9e0e9f6e0b8$var$isElementInScope(element, scope.current)) return true;
    }
    return false;
}
function $4e07e9e0e9f6e0b8$var$isElementInScope(element, scope) {
    return scope.some((node)=>node.contains(element)
    );
}
function $4e07e9e0e9f6e0b8$var$isElementInChildScope(element, scope) {
    // node.contains in isElementInScope covers child scopes that are also DOM children,
    // but does not cover child scopes in portals.
    for (let s of $4e07e9e0e9f6e0b8$var$scopes.keys()){
        if ((s === scope || $4e07e9e0e9f6e0b8$var$isAncestorScope(scope, s)) && $4e07e9e0e9f6e0b8$var$isElementInScope(element, s.current)) return true;
    }
    return false;
}
function $4e07e9e0e9f6e0b8$var$isAncestorScope(ancestor, scope) {
    let parent = $4e07e9e0e9f6e0b8$var$scopes.get(scope);
    if (!parent) return false;
    if (parent === ancestor) return true;
    return $4e07e9e0e9f6e0b8$var$isAncestorScope(ancestor, parent);
}
function $4e07e9e0e9f6e0b8$var$focusElement(element, scroll = false) {
    if (element != null && !scroll) try {
        $a424ea782c64243d$export$80f3e147d781571c(element);
    } catch (err) {
    // ignore
    }
    else if (element != null) try {
        element.focus();
    } catch (err1) {
    // ignore
    }
}
function $4e07e9e0e9f6e0b8$var$focusFirstInScope(scope) {
    let sentinel = scope[0].previousElementSibling;
    let walker = $4e07e9e0e9f6e0b8$export$2d6ec8fc375ceafa($4e07e9e0e9f6e0b8$var$getScopeRoot(scope), {
        tabbable: true
    }, scope);
    walker.currentNode = sentinel;
    $4e07e9e0e9f6e0b8$var$focusElement(walker.nextNode());
}
function $4e07e9e0e9f6e0b8$var$useAutoFocus(scopeRef, autoFocus) {
    const autoFocusRef = ($parcel$interopDefault($7qnVn$react)).useRef(autoFocus);
    $7qnVn$react.useEffect(()=>{
        if (autoFocusRef.current) {
            $4e07e9e0e9f6e0b8$var$activeScope = scopeRef;
            if (!$4e07e9e0e9f6e0b8$var$isElementInScope(document.activeElement, $4e07e9e0e9f6e0b8$var$activeScope.current)) $4e07e9e0e9f6e0b8$var$focusFirstInScope(scopeRef.current);
        }
        autoFocusRef.current = false;
    }, []);
}
function $4e07e9e0e9f6e0b8$var$useRestoreFocus(scopeRef, restoreFocus, contain) {
    // create a ref during render instead of useLayoutEffect so the active element is saved before a child with autoFocus=true mounts.
    const nodeToRestoreRef = $7qnVn$react.useRef(typeof document !== 'undefined' ? document.activeElement : null);
    // useLayoutEffect instead of useEffect so the active element is saved synchronously instead of asynchronously.
    $7qnVn$reactariautils.useLayoutEffect(()=>{
        let nodeToRestore = nodeToRestoreRef.current;
        if (!restoreFocus) return;
        // Handle the Tab key so that tabbing out of the scope goes to the next element
        // after the node that had focus when the scope mounted. This is important when
        // using portals for overlays, so that focus goes to the expected element when
        // tabbing out of the overlay.
        let onKeyDown = (e)=>{
            if (e.key !== 'Tab' || e.altKey || e.ctrlKey || e.metaKey) return;
            let focusedElement = document.activeElement;
            if (!$4e07e9e0e9f6e0b8$var$isElementInScope(focusedElement, scopeRef.current)) return;
            // Create a DOM tree walker that matches all tabbable elements
            let walker = $4e07e9e0e9f6e0b8$export$2d6ec8fc375ceafa(document.body, {
                tabbable: true
            });
            // Find the next tabbable element after the currently focused element
            walker.currentNode = focusedElement;
            let nextElement = e.shiftKey ? walker.previousNode() : walker.nextNode();
            if (!document.body.contains(nodeToRestore) || nodeToRestore === document.body) nodeToRestore = null;
            // If there is no next element, or it is outside the current scope, move focus to the
            // next element after the node to restore to instead.
            if ((!nextElement || !$4e07e9e0e9f6e0b8$var$isElementInScope(nextElement, scopeRef.current)) && nodeToRestore) {
                walker.currentNode = nodeToRestore;
                // Skip over elements within the scope, in case the scope immediately follows the node to restore.
                do nextElement = e.shiftKey ? walker.previousNode() : walker.nextNode();
                while ($4e07e9e0e9f6e0b8$var$isElementInScope(nextElement, scopeRef.current))
                e.preventDefault();
                e.stopPropagation();
                if (nextElement) $4e07e9e0e9f6e0b8$var$focusElement(nextElement, true);
                else // If there is no next element and the nodeToRestore isn't within a FocusScope (i.e. we are leaving the top level focus scope)
                // then move focus to the body.
                // Otherwise restore focus to the nodeToRestore (e.g menu within a popover -> tabbing to close the menu should move focus to menu trigger)
                if (!$4e07e9e0e9f6e0b8$var$isElementInAnyScope(nodeToRestore)) focusedElement.blur();
                else $4e07e9e0e9f6e0b8$var$focusElement(nodeToRestore, true);
            }
        };
        if (!contain) document.addEventListener('keydown', onKeyDown, true);
        return ()=>{
            if (!contain) document.removeEventListener('keydown', onKeyDown, true);
            if (restoreFocus && nodeToRestore && $4e07e9e0e9f6e0b8$var$isElementInScope(document.activeElement, scopeRef.current)) requestAnimationFrame(()=>{
                if (document.body.contains(nodeToRestore)) $4e07e9e0e9f6e0b8$var$focusElement(nodeToRestore);
            });
        };
    }, [
        scopeRef,
        restoreFocus,
        contain
    ]);
}
function $4e07e9e0e9f6e0b8$export$2d6ec8fc375ceafa(root, opts, scope) {
    let selector = opts?.tabbable ? $4e07e9e0e9f6e0b8$var$TABBABLE_ELEMENT_SELECTOR : $4e07e9e0e9f6e0b8$var$FOCUSABLE_ELEMENT_SELECTOR;
    let walker = document.createTreeWalker(root, NodeFilter.SHOW_ELEMENT, {
        acceptNode (node) {
            // Skip nodes inside the starting node.
            if (opts?.from?.contains(node)) return NodeFilter.FILTER_REJECT;
            if (node.matches(selector) && $9793aa05cd766621$export$e989c0fffaa6b27a(node) && (!scope || $4e07e9e0e9f6e0b8$var$isElementInScope(node, scope))) return NodeFilter.FILTER_ACCEPT;
            return NodeFilter.FILTER_SKIP;
        }
    });
    if (opts?.from) walker.currentNode = opts.from;
    return walker;
}
function $4e07e9e0e9f6e0b8$export$c5251b9e124bf29(ref) {
    return {
        focusNext (opts = {
        }) {
            let root = ref.current;
            let { from: from , tabbable: tabbable , wrap: wrap  } = opts;
            let node = from || document.activeElement;
            let walker = $4e07e9e0e9f6e0b8$export$2d6ec8fc375ceafa(root, {
                tabbable: tabbable
            });
            if (root.contains(node)) walker.currentNode = node;
            let nextNode = walker.nextNode();
            if (!nextNode && wrap) {
                walker.currentNode = root;
                nextNode = walker.nextNode();
            }
            if (nextNode) $4e07e9e0e9f6e0b8$var$focusElement(nextNode, true);
            return nextNode;
        },
        focusPrevious (opts = {
        }) {
            let root = ref.current;
            let { from: from , tabbable: tabbable , wrap: wrap  } = opts;
            let node = from || document.activeElement;
            let walker = $4e07e9e0e9f6e0b8$export$2d6ec8fc375ceafa(root, {
                tabbable: tabbable
            });
            if (root.contains(node)) walker.currentNode = node;
            else {
                let next = $4e07e9e0e9f6e0b8$var$last(walker);
                if (next) $4e07e9e0e9f6e0b8$var$focusElement(next, true);
                return next;
            }
            let previousNode = walker.previousNode();
            if (!previousNode && wrap) {
                walker.currentNode = root;
                previousNode = $4e07e9e0e9f6e0b8$var$last(walker);
            }
            if (previousNode) $4e07e9e0e9f6e0b8$var$focusElement(previousNode, true);
            return previousNode;
        },
        focusFirst (opts = {
        }) {
            let root = ref.current;
            let { tabbable: tabbable  } = opts;
            let walker = $4e07e9e0e9f6e0b8$export$2d6ec8fc375ceafa(root, {
                tabbable: tabbable
            });
            let nextNode = walker.nextNode();
            if (nextNode) $4e07e9e0e9f6e0b8$var$focusElement(nextNode, true);
            return nextNode;
        },
        focusLast (opts = {
        }) {
            let root = ref.current;
            let { tabbable: tabbable  } = opts;
            let walker = $4e07e9e0e9f6e0b8$export$2d6ec8fc375ceafa(root, {
                tabbable: tabbable
            });
            let next = $4e07e9e0e9f6e0b8$var$last(walker);
            if (next) $4e07e9e0e9f6e0b8$var$focusElement(next, true);
            return next;
        }
    };
}
function $4e07e9e0e9f6e0b8$var$last(walker) {
    let next;
    let last;
    do {
        last = walker.lastChild();
        if (last) next = last;
    }while (last)
    return next;
}


var $1b048bf2853bccb4$exports = {};

$parcel$export($1b048bf2853bccb4$exports, "FocusRing", () => $1b048bf2853bccb4$export$1a38b4ad7f578e1d);



var $72aa0937366f9cc2$exports = {};

$parcel$export($72aa0937366f9cc2$exports, "useFocusRing", () => $72aa0937366f9cc2$export$4e328f61c538687f);



function $72aa0937366f9cc2$export$4e328f61c538687f(props = {
}) {
    let { autoFocus: autoFocus = false , isTextInput: isTextInput , within: within  } = props;
    let state = $7qnVn$react.useRef({
        isFocused: false,
        isFocusVisible: autoFocus || $7qnVn$reactariainteractions.isFocusVisible()
    }).current;
    let [isFocused1, setFocused] = $7qnVn$react.useState(false);
    let [isFocusVisibleState, setFocusVisible] = $7qnVn$react.useState(()=>state.isFocused && state.isFocusVisible
    );
    let updateState = ()=>setFocusVisible(state.isFocused && state.isFocusVisible)
    ;
    let onFocusChange = (isFocused)=>{
        state.isFocused = isFocused;
        setFocused(isFocused);
        updateState();
    };
    $7qnVn$reactariainteractions.useFocusVisibleListener((isFocusVisible)=>{
        state.isFocusVisible = isFocusVisible;
        updateState();
    }, [], {
        isTextInput: isTextInput
    });
    let { focusProps: focusProps  } = $7qnVn$reactariainteractions.useFocus({
        isDisabled: within,
        onFocusChange: onFocusChange
    });
    let { focusWithinProps: focusWithinProps  } = $7qnVn$reactariainteractions.useFocusWithin({
        isDisabled: !within,
        onFocusWithinChange: onFocusChange
    });
    return {
        isFocused: isFocused1,
        isFocusVisible: state.isFocused && isFocusVisibleState,
        focusProps: within ? focusWithinProps : focusProps
    };
}


function $1b048bf2853bccb4$export$1a38b4ad7f578e1d(props) {
    let { children: children , focusClass: focusClass , focusRingClass: focusRingClass  } = props;
    let { isFocused: isFocused , isFocusVisible: isFocusVisible , focusProps: focusProps  } = $72aa0937366f9cc2$export$4e328f61c538687f(props);
    let child = ($parcel$interopDefault($7qnVn$react)).Children.only(children);
    return(/*#__PURE__*/ ($parcel$interopDefault($7qnVn$react)).cloneElement(child, $7qnVn$reactariautils.mergeProps(child.props, {
        ...focusProps,
        className: ($parcel$interopDefault($7qnVn$clsx))({
            [focusClass || '']: isFocused,
            [focusRingClass || '']: isFocusVisible
        })
    })));
}


var $be91893942c6d355$exports = {};

$parcel$export($be91893942c6d355$exports, "FocusableProvider", () => $be91893942c6d355$export$13f3202a3e5ddd5);
$parcel$export($be91893942c6d355$exports, "useFocusable", () => $be91893942c6d355$export$4c014de7c8940b4c);



let $be91893942c6d355$var$FocusableContext = /*#__PURE__*/ ($parcel$interopDefault($7qnVn$react)).createContext(null);
function $be91893942c6d355$var$useFocusableContext(ref) {
    let context = $7qnVn$react.useContext($be91893942c6d355$var$FocusableContext) || {
    };
    $7qnVn$reactariautils.useSyncRef(context, ref);
    // eslint-disable-next-line
    let { ref: _ , ...otherProps } = context;
    return otherProps;
}
/**
 * Provides DOM props to the nearest focusable child.
 */ function $be91893942c6d355$var$FocusableProvider(props, ref) {
    let { children: children , ...otherProps } = props;
    let context = {
        ...otherProps,
        ref: ref
    };
    return(/*#__PURE__*/ ($parcel$interopDefault($7qnVn$react)).createElement($be91893942c6d355$var$FocusableContext.Provider, {
        value: context
    }, children));
}
let $be91893942c6d355$export$13f3202a3e5ddd5 = /*#__PURE__*/ ($parcel$interopDefault($7qnVn$react)).forwardRef($be91893942c6d355$var$FocusableProvider);
function $be91893942c6d355$export$4c014de7c8940b4c(props, domRef) {
    let { focusProps: focusProps  } = $7qnVn$reactariainteractions.useFocus(props);
    let { keyboardProps: keyboardProps  } = $7qnVn$reactariainteractions.useKeyboard(props);
    let interactions = $7qnVn$reactariautils.mergeProps(focusProps, keyboardProps);
    let domProps = $be91893942c6d355$var$useFocusableContext(domRef);
    let interactionProps = props.isDisabled ? {
    } : domProps;
    let autoFocusRef = $7qnVn$react.useRef(props.autoFocus);
    $7qnVn$react.useEffect(()=>{
        if (autoFocusRef.current && domRef.current) domRef.current.focus();
        autoFocusRef.current = false;
    }, []);
    return {
        focusableProps: $7qnVn$reactariautils.mergeProps({
            ...interactions,
            tabIndex: props.excludeFromTabOrder && !props.isDisabled ? -1 : undefined
        }, interactionProps)
    };
}




$parcel$exportWildcard(module.exports, $4e07e9e0e9f6e0b8$exports);
$parcel$exportWildcard(module.exports, $1b048bf2853bccb4$exports);
$parcel$exportWildcard(module.exports, $be91893942c6d355$exports);
$parcel$exportWildcard(module.exports, $72aa0937366f9cc2$exports);
$parcel$exportWildcard(module.exports, $a424ea782c64243d$exports);


//# sourceMappingURL=main.js.map
