import $gskSG$react, {useRef as $gskSG$useRef, useState as $gskSG$useState, useEffect as $gskSG$useEffect, useCallback as $gskSG$useCallback} from "react";
import {useSSRSafeId as $gskSG$useSSRSafeId} from "@react-aria/ssr";
import $gskSG$clsx from "clsx";
import {clamp as $5cdbf4ddafd135bc$re_export$clamp, snapValueToStep as $5cdbf4ddafd135bc$re_export$snapValueToStep} from "@react-stately/utils";

function $parcel$export(e, n, v, s) {
  Object.defineProperty(e, n, {get: v, set: s, enumerable: true, configurable: true});
}
var $4208ab27be92763a$exports = {};

$parcel$export($4208ab27be92763a$exports, "useId", () => $4208ab27be92763a$export$f680877a34711e37);
$parcel$export($4208ab27be92763a$exports, "mergeIds", () => $4208ab27be92763a$export$cd8c9cb68f842629);
$parcel$export($4208ab27be92763a$exports, "useSlotId", () => $4208ab27be92763a$export$b4cc09c592e8fdb8);

var $62918828a5c4cefe$exports = {};

$parcel$export($62918828a5c4cefe$exports, "useLayoutEffect", () => $62918828a5c4cefe$export$e5c5a5f917a5871c);

const $62918828a5c4cefe$export$e5c5a5f917a5871c = typeof window !== 'undefined' ? $gskSG$react.useLayoutEffect : ()=>{
};




let $4208ab27be92763a$var$idsUpdaterMap = new Map();
function $4208ab27be92763a$export$f680877a34711e37(defaultId) {
    let isRendering = $gskSG$useRef(true);
    isRendering.current = true;
    let [value, setValue] = $gskSG$useState(defaultId);
    let nextId = $gskSG$useRef(null);
    let res = $gskSG$useSSRSafeId(value);
    // don't memo this, we want it new each render so that the Effects always run
    let updateValue = (val)=>{
        if (!isRendering.current) setValue(val);
        else nextId.current = val;
    };
    $4208ab27be92763a$var$idsUpdaterMap.set(res, updateValue);
    $62918828a5c4cefe$export$e5c5a5f917a5871c(()=>{
        isRendering.current = false;
    }, [
        updateValue
    ]);
    $62918828a5c4cefe$export$e5c5a5f917a5871c(()=>{
        let r = res;
        return ()=>{
            $4208ab27be92763a$var$idsUpdaterMap.delete(r);
        };
    }, [
        res
    ]);
    $gskSG$useEffect(()=>{
        let newId = nextId.current;
        if (newId) {
            setValue(newId);
            nextId.current = null;
        }
    }, [
        setValue,
        updateValue
    ]);
    return res;
}
function $4208ab27be92763a$export$cd8c9cb68f842629(idA, idB) {
    if (idA === idB) return idA;
    let setIdA = $4208ab27be92763a$var$idsUpdaterMap.get(idA);
    if (setIdA) {
        setIdA(idB);
        return idB;
    }
    let setIdB = $4208ab27be92763a$var$idsUpdaterMap.get(idB);
    if (setIdB) {
        setIdB(idA);
        return idA;
    }
    return idB;
}
function $4208ab27be92763a$export$b4cc09c592e8fdb8(depArray = []) {
    let id = $4208ab27be92763a$export$f680877a34711e37();
    let [resolvedId, setResolvedId] = $8bfb318ccfa2e412$export$14d238f342723f25(id);
    let updateId = $gskSG$useCallback(()=>{
        setResolvedId(function*() {
            yield id;
            yield document.getElementById(id) ? id : null;
        });
    }, [
        id,
        setResolvedId
    ]);
    $62918828a5c4cefe$export$e5c5a5f917a5871c(updateId, [
        id,
        updateId,
        ...depArray
    ]);
    return resolvedId;
}


var $2aefb161b9a41928$exports = {};

$parcel$export($2aefb161b9a41928$exports, "chain", () => $2aefb161b9a41928$export$e08e3b67e392101e);
function $2aefb161b9a41928$export$e08e3b67e392101e(...callbacks) {
    return (...args)=>{
        for (let callback of callbacks)if (typeof callback === 'function') callback(...args);
    };
}


var $699afe8e9e0f66de$exports = {};

$parcel$export($699afe8e9e0f66de$exports, "mergeProps", () => $699afe8e9e0f66de$export$9d1611c77c2fe928);



function $699afe8e9e0f66de$export$9d1611c77c2fe928(...args) {
    // Start with a base clone of the first argument. This is a lot faster than starting
    // with an empty object and adding properties as we go.
    let result = {
        ...args[0]
    };
    for(let i = 1; i < args.length; i++){
        let props = args[i];
        for(let key in props){
            let a = result[key];
            let b = props[key];
            // Chain events
            if (typeof a === 'function' && typeof b === 'function' && // This is a lot faster than a regex.
            key[0] === 'o' && key[1] === 'n' && key.charCodeAt(2) >= /* 'A' */ 65 && key.charCodeAt(2) <= /* 'Z' */ 90) result[key] = $2aefb161b9a41928$export$e08e3b67e392101e(a, b);
            else if ((key === 'className' || key === 'UNSAFE_className') && typeof a === 'string' && typeof b === 'string') result[key] = $gskSG$clsx(a, b);
            else if (key === 'id' && a && b) result.id = $4208ab27be92763a$export$cd8c9cb68f842629(a, b);
            else result[key] = b !== undefined ? b : a;
        }
    }
    return result;
}


var $7efcb978e02fb174$exports = {};

$parcel$export($7efcb978e02fb174$exports, "filterDOMProps", () => $7efcb978e02fb174$export$457c3d6518dd4c6f);
const $7efcb978e02fb174$var$DOMPropNames = new Set([
    'id'
]);
const $7efcb978e02fb174$var$labelablePropNames = new Set([
    'aria-label',
    'aria-labelledby',
    'aria-describedby',
    'aria-details'
]);
const $7efcb978e02fb174$var$propRe = /^(data-.*)$/;
function $7efcb978e02fb174$export$457c3d6518dd4c6f(props, opts = {
}) {
    let { labelable: labelable , propNames: propNames  } = opts;
    let filteredProps = {
    };
    for(const prop in props)if (Object.prototype.hasOwnProperty.call(props, prop) && ($7efcb978e02fb174$var$DOMPropNames.has(prop) || labelable && $7efcb978e02fb174$var$labelablePropNames.has(prop) || propNames?.has(prop) || $7efcb978e02fb174$var$propRe.test(prop))) filteredProps[prop] = props[prop];
    return filteredProps;
}


var $0172e2a3384c2851$exports = {};

$parcel$export($0172e2a3384c2851$exports, "focusWithoutScrolling", () => $0172e2a3384c2851$export$de79e2c695e052f3);
function $0172e2a3384c2851$export$de79e2c695e052f3(element) {
    if ($0172e2a3384c2851$var$supportsPreventScroll()) element.focus({
        preventScroll: true
    });
    else {
        let scrollableElements = $0172e2a3384c2851$var$getScrollableElements(element);
        element.focus();
        $0172e2a3384c2851$var$restoreScrollPosition(scrollableElements);
    }
}
let $0172e2a3384c2851$var$supportsPreventScrollCached = null;
function $0172e2a3384c2851$var$supportsPreventScroll() {
    if ($0172e2a3384c2851$var$supportsPreventScrollCached == null) {
        $0172e2a3384c2851$var$supportsPreventScrollCached = false;
        try {
            var focusElem = document.createElement('div');
            focusElem.focus({
                get preventScroll () {
                    $0172e2a3384c2851$var$supportsPreventScrollCached = true;
                    return true;
                }
            });
        } catch (e) {
        // Ignore
        }
    }
    return $0172e2a3384c2851$var$supportsPreventScrollCached;
}
function $0172e2a3384c2851$var$getScrollableElements(element) {
    var parent = element.parentNode;
    var scrollableElements = [];
    var rootScrollingElement = document.scrollingElement || document.documentElement;
    while(parent instanceof HTMLElement && parent !== rootScrollingElement){
        if (parent.offsetHeight < parent.scrollHeight || parent.offsetWidth < parent.scrollWidth) scrollableElements.push({
            element: parent,
            scrollTop: parent.scrollTop,
            scrollLeft: parent.scrollLeft
        });
        parent = parent.parentNode;
    }
    if (rootScrollingElement instanceof HTMLElement) scrollableElements.push({
        element: rootScrollingElement,
        scrollTop: rootScrollingElement.scrollTop,
        scrollLeft: rootScrollingElement.scrollLeft
    });
    return scrollableElements;
}
function $0172e2a3384c2851$var$restoreScrollPosition(scrollableElements) {
    for (let { element: element , scrollTop: scrollTop , scrollLeft: scrollLeft  } of scrollableElements){
        element.scrollTop = scrollTop;
        element.scrollLeft = scrollLeft;
    }
}


var $5062b1512bdf762b$exports = {};

$parcel$export($5062b1512bdf762b$exports, "getOffset", () => $5062b1512bdf762b$export$622cea445a1c5b7d);
function $5062b1512bdf762b$export$622cea445a1c5b7d(element, reverse, orientation = 'horizontal') {
    let rect = element.getBoundingClientRect();
    if (reverse) return orientation === 'horizontal' ? rect.right : rect.bottom;
    return orientation === 'horizontal' ? rect.left : rect.top;
}


var $5cdbf4ddafd135bc$exports = {};

$parcel$export($5cdbf4ddafd135bc$exports, "clamp", () => $5cdbf4ddafd135bc$re_export$clamp);
$parcel$export($5cdbf4ddafd135bc$exports, "snapValueToStep", () => $5cdbf4ddafd135bc$re_export$snapValueToStep);



var $fdecdd2f4116564c$exports = {};

$parcel$export($fdecdd2f4116564c$exports, "runAfterTransition", () => $fdecdd2f4116564c$export$24490316f764c430);
/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ // We store a global list of elements that are currently transitioning,
// mapped to a set of CSS properties that are transitioning for that element.
// This is necessary rather than a simple count of transitions because of browser
// bugs, e.g. Chrome sometimes fires both transitionend and transitioncancel rather
// than one or the other. So we need to track what's actually transitioning so that
// we can ignore these duplicate events.
let $fdecdd2f4116564c$var$transitionsByElement = new Map();
// A list of callbacks to call once there are no transitioning elements.
let $fdecdd2f4116564c$var$transitionCallbacks = new Set();
function $fdecdd2f4116564c$var$setupGlobalEvents() {
    if (typeof window === 'undefined') return;
    let onTransitionStart = (e)=>{
        // Add the transitioning property to the list for this element.
        let transitions = $fdecdd2f4116564c$var$transitionsByElement.get(e.target);
        if (!transitions) {
            transitions = new Set();
            $fdecdd2f4116564c$var$transitionsByElement.set(e.target, transitions);
            // The transitioncancel event must be registered on the element itself, rather than as a global
            // event. This enables us to handle when the node is deleted from the document while it is transitioning.
            // In that case, the cancel event would have nowhere to bubble to so we need to handle it directly.
            e.target.addEventListener('transitioncancel', onTransitionEnd);
        }
        transitions.add(e.propertyName);
    };
    let onTransitionEnd = (e)=>{
        // Remove property from list of transitioning properties.
        let properties = $fdecdd2f4116564c$var$transitionsByElement.get(e.target);
        if (!properties) return;
        properties.delete(e.propertyName);
        // If empty, remove transitioncancel event, and remove the element from the list of transitioning elements.
        if (properties.size === 0) {
            e.target.removeEventListener('transitioncancel', onTransitionEnd);
            $fdecdd2f4116564c$var$transitionsByElement.delete(e.target);
        }
        // If no transitioning elements, call all of the queued callbacks.
        if ($fdecdd2f4116564c$var$transitionsByElement.size === 0) {
            for (let cb of $fdecdd2f4116564c$var$transitionCallbacks)cb();
            $fdecdd2f4116564c$var$transitionCallbacks.clear();
        }
    };
    document.body.addEventListener('transitionrun', onTransitionStart);
    document.body.addEventListener('transitionend', onTransitionEnd);
}
if (typeof document !== 'undefined') {
    if (document.readyState !== 'loading') $fdecdd2f4116564c$var$setupGlobalEvents();
    else document.addEventListener('DOMContentLoaded', $fdecdd2f4116564c$var$setupGlobalEvents);
}
function $fdecdd2f4116564c$export$24490316f764c430(fn) {
    // Wait one frame to see if an animation starts, e.g. a transition on mount.
    requestAnimationFrame(()=>{
        // If no transitions are running, call the function immediately.
        // Otherwise, add it to a list of callbacks to run at the end of the animation.
        if ($fdecdd2f4116564c$var$transitionsByElement.size === 0) fn();
        else $fdecdd2f4116564c$var$transitionCallbacks.add(fn);
    });
}


var $95a0e07fe544f4e9$exports = {};

$parcel$export($95a0e07fe544f4e9$exports, "useDrag1D", () => $95a0e07fe544f4e9$export$7bbed75feba39706);


// Keep track of elements that we are currently handling dragging for via useDrag1D.
// If there's an ancestor and a descendant both using useDrag1D(), and the user starts
// dragging the descendant, we don't want useDrag1D events to fire for the ancestor.
const $95a0e07fe544f4e9$var$draggingElements = [];
function $95a0e07fe544f4e9$export$7bbed75feba39706(props) {
    console.warn('useDrag1D is deprecated, please use `useMove` instead https://react-spectrum.adobe.com/react-aria/useMove.html');
    let { containerRef: containerRef , reverse: reverse , orientation: orientation , onHover: onHover , onDrag: onDrag , onPositionChange: onPositionChange , onIncrement: onIncrement , onDecrement: onDecrement , onIncrementToMax: onIncrementToMax , onDecrementToMin: onDecrementToMin , onCollapseToggle: onCollapseToggle  } = props;
    let getPosition = (e)=>orientation === 'horizontal' ? e.clientX : e.clientY
    ;
    let getNextOffset = (e)=>{
        let containerOffset = $5062b1512bdf762b$export$622cea445a1c5b7d(containerRef.current, reverse, orientation);
        let mouseOffset = getPosition(e);
        let nextOffset = reverse ? containerOffset - mouseOffset : mouseOffset - containerOffset;
        return nextOffset;
    };
    let dragging = $gskSG$useRef(false);
    let prevPosition = $gskSG$useRef(0);
    // Keep track of the current handlers in a ref so that the events can access them.
    let handlers = $gskSG$useRef({
        onPositionChange: onPositionChange,
        onDrag: onDrag
    });
    handlers.current.onDrag = onDrag;
    handlers.current.onPositionChange = onPositionChange;
    let onMouseDragged = (e)=>{
        e.preventDefault();
        let nextOffset = getNextOffset(e);
        if (!dragging.current) {
            dragging.current = true;
            if (handlers.current.onDrag) handlers.current.onDrag(true);
            if (handlers.current.onPositionChange) handlers.current.onPositionChange(nextOffset);
        }
        if (prevPosition.current === nextOffset) return;
        prevPosition.current = nextOffset;
        if (onPositionChange) onPositionChange(nextOffset);
    };
    let onMouseUp = (e)=>{
        const target = e.target;
        dragging.current = false;
        let nextOffset = getNextOffset(e);
        if (handlers.current.onDrag) handlers.current.onDrag(false);
        if (handlers.current.onPositionChange) handlers.current.onPositionChange(nextOffset);
        $95a0e07fe544f4e9$var$draggingElements.splice($95a0e07fe544f4e9$var$draggingElements.indexOf(target), 1);
        window.removeEventListener('mouseup', onMouseUp, false);
        window.removeEventListener('mousemove', onMouseDragged, false);
    };
    let onMouseDown = (e)=>{
        const target = e.currentTarget;
        // If we're already handling dragging on a descendant with useDrag1D, then
        // we don't want to handle the drag motion on this target as well.
        if ($95a0e07fe544f4e9$var$draggingElements.some((elt)=>target.contains(elt)
        )) return;
        $95a0e07fe544f4e9$var$draggingElements.push(target);
        window.addEventListener('mousemove', onMouseDragged, false);
        window.addEventListener('mouseup', onMouseUp, false);
    };
    let onMouseEnter = ()=>{
        if (onHover) onHover(true);
    };
    let onMouseOut = ()=>{
        if (onHover) onHover(false);
    };
    let onKeyDown = (e)=>{
        switch(e.key){
            case 'Left':
            case 'ArrowLeft':
                if (orientation === 'horizontal') {
                    e.preventDefault();
                    if (onDecrement && !reverse) onDecrement();
                    else if (onIncrement && reverse) onIncrement();
                }
                break;
            case 'Up':
            case 'ArrowUp':
                if (orientation === 'vertical') {
                    e.preventDefault();
                    if (onDecrement && !reverse) onDecrement();
                    else if (onIncrement && reverse) onIncrement();
                }
                break;
            case 'Right':
            case 'ArrowRight':
                if (orientation === 'horizontal') {
                    e.preventDefault();
                    if (onIncrement && !reverse) onIncrement();
                    else if (onDecrement && reverse) onDecrement();
                }
                break;
            case 'Down':
            case 'ArrowDown':
                if (orientation === 'vertical') {
                    e.preventDefault();
                    if (onIncrement && !reverse) onIncrement();
                    else if (onDecrement && reverse) onDecrement();
                }
                break;
            case 'Home':
                e.preventDefault();
                if (onDecrementToMin) onDecrementToMin();
                break;
            case 'End':
                e.preventDefault();
                if (onIncrementToMax) onIncrementToMax();
                break;
            case 'Enter':
                e.preventDefault();
                if (onCollapseToggle) onCollapseToggle();
                break;
        }
    };
    return {
        onMouseDown: onMouseDown,
        onMouseEnter: onMouseEnter,
        onMouseOut: onMouseOut,
        onKeyDown: onKeyDown
    };
}


var $042598a43c3fee40$exports = {};

$parcel$export($042598a43c3fee40$exports, "useGlobalListeners", () => $042598a43c3fee40$export$4eaf04e54aa8eed6);

function $042598a43c3fee40$export$4eaf04e54aa8eed6() {
    let globalListeners = $gskSG$useRef(new Map());
    let addGlobalListener = $gskSG$useCallback((eventTarget, type, listener, options)=>{
        // Make sure we remove the listener after it is called with the `once` option.
        let fn = options?.once ? (...args)=>{
            globalListeners.current.delete(listener);
            listener(...args);
        } : listener;
        globalListeners.current.set(listener, {
            type: type,
            eventTarget: eventTarget,
            fn: fn,
            options: options
        });
        eventTarget.addEventListener(type, listener, options);
    }, []);
    let removeGlobalListener = $gskSG$useCallback((eventTarget, type, listener, options)=>{
        let fn = globalListeners.current.get(listener)?.fn || listener;
        eventTarget.removeEventListener(type, fn, options);
        globalListeners.current.delete(listener);
    }, []);
    let removeAllGlobalListeners = $gskSG$useCallback(()=>{
        globalListeners.current.forEach((value, key)=>{
            removeGlobalListener(value.eventTarget, value.type, key, value.options);
        });
    }, [
        removeGlobalListener
    ]);
    // eslint-disable-next-line arrow-body-style
    $gskSG$useEffect(()=>{
        return removeAllGlobalListeners;
    }, [
        removeAllGlobalListeners
    ]);
    return {
        addGlobalListener: addGlobalListener,
        removeGlobalListener: removeGlobalListener,
        removeAllGlobalListeners: removeAllGlobalListeners
    };
}


var $2ab91c20d1fbac23$exports = {};

$parcel$export($2ab91c20d1fbac23$exports, "useLabels", () => $2ab91c20d1fbac23$export$d6875122194c7b44);

function $2ab91c20d1fbac23$export$d6875122194c7b44(props, defaultLabel) {
    let { id: id , 'aria-label': label , 'aria-labelledby': labelledBy  } = props;
    // If there is both an aria-label and aria-labelledby,
    // combine them by pointing to the element itself.
    id = $4208ab27be92763a$export$f680877a34711e37(id);
    if (labelledBy && label) {
        let ids = new Set([
            ...labelledBy.trim().split(/\s+/),
            id
        ]);
        labelledBy = [
            ...ids
        ].join(' ');
    } else if (labelledBy) labelledBy = labelledBy.trim().split(/\s+/).join(' ');
    // If no labels are provided, use the default
    if (!label && !labelledBy && defaultLabel) label = defaultLabel;
    return {
        id: id,
        'aria-label': label,
        'aria-labelledby': labelledBy
    };
}


var $1ea3613dec903cb9$exports = {};

$parcel$export($1ea3613dec903cb9$exports, "useObjectRef", () => $1ea3613dec903cb9$export$4338b53315abf666);


function $1ea3613dec903cb9$export$4338b53315abf666(forwardedRef) {
    const objRef = $gskSG$useRef();
    /**
   * We're using `useLayoutEffect` here instead of `useEffect` because we want
   * to make sure that the `ref` value is up to date before other places in the
   * the execution cycle try to read it.
   */ $62918828a5c4cefe$export$e5c5a5f917a5871c(()=>{
        if (!forwardedRef) return;
        if (typeof forwardedRef === 'function') forwardedRef(objRef.current);
        else forwardedRef.current = objRef.current;
    }, [
        forwardedRef
    ]);
    return objRef;
}


var $d3ab8ae13db3a1fd$exports = {};

$parcel$export($d3ab8ae13db3a1fd$exports, "useUpdateEffect", () => $d3ab8ae13db3a1fd$export$496315a1608d9602);

function $d3ab8ae13db3a1fd$export$496315a1608d9602(effect, dependencies) {
    const isInitialMount = $gskSG$useRef(true);
    $gskSG$useEffect(()=>{
        if (isInitialMount.current) isInitialMount.current = false;
        else effect();
    // eslint-disable-next-line react-hooks/exhaustive-deps
    }, dependencies);
}



var $f3e728a941364b05$exports = {};

$parcel$export($f3e728a941364b05$exports, "useResizeObserver", () => $f3e728a941364b05$export$683480f191c0e3ea);

function $f3e728a941364b05$var$hasResizeObserver() {
    return typeof window.ResizeObserver !== 'undefined';
}
function $f3e728a941364b05$export$683480f191c0e3ea(options) {
    const { ref: ref , onResize: onResize  } = options;
    $gskSG$useEffect(()=>{
        let element = ref?.current;
        if (!element) return;
        if (!$f3e728a941364b05$var$hasResizeObserver()) {
            window.addEventListener('resize', onResize, false);
            return ()=>{
                window.removeEventListener('resize', onResize, false);
            };
        } else {
            const resizeObserverInstance = new window.ResizeObserver((entries)=>{
                if (!entries.length) return;
                onResize();
            });
            resizeObserverInstance.observe(element);
            return ()=>{
                if (element) resizeObserverInstance.unobserve(element);
            };
        }
    }, [
        onResize,
        ref
    ]);
}


var $518b8f251641d71b$exports = {};

$parcel$export($518b8f251641d71b$exports, "useSyncRef", () => $518b8f251641d71b$export$4debdb1a3f0fa79e);

function $518b8f251641d71b$export$4debdb1a3f0fa79e(context, ref) {
    $62918828a5c4cefe$export$e5c5a5f917a5871c(()=>{
        if (context && context.ref && ref) {
            context.ref.current = ref.current;
            return ()=>{
                context.ref.current = null;
            };
        }
    }, [
        context,
        ref
    ]);
}


var $2fe8625dffd76a00$exports = {};

$parcel$export($2fe8625dffd76a00$exports, "getScrollParent", () => $2fe8625dffd76a00$export$cfa2225e87938781);
function $2fe8625dffd76a00$export$cfa2225e87938781(node) {
    while(node && !$2fe8625dffd76a00$var$isScrollable(node))node = node.parentElement;
    return node || document.scrollingElement || document.documentElement;
}
function $2fe8625dffd76a00$var$isScrollable(node) {
    let style = window.getComputedStyle(node);
    return /(auto|scroll)/.test(style.overflow + style.overflowX + style.overflowY);
}


var $c5fe598a15f005e5$exports = {};

$parcel$export($c5fe598a15f005e5$exports, "useViewportSize", () => $c5fe598a15f005e5$export$d699905dd57c73ca);

// @ts-ignore
let $c5fe598a15f005e5$var$visualViewport = typeof window !== 'undefined' && window.visualViewport;
function $c5fe598a15f005e5$export$d699905dd57c73ca() {
    let [size1, setSize] = $gskSG$useState(()=>$c5fe598a15f005e5$var$getViewportSize()
    );
    $gskSG$useEffect(()=>{
        // Use visualViewport api to track available height even on iOS virtual keyboard opening
        let onResize = ()=>{
            setSize((size)=>{
                let newSize = $c5fe598a15f005e5$var$getViewportSize();
                if (newSize.width === size.width && newSize.height === size.height) return size;
                return newSize;
            });
        };
        if (!$c5fe598a15f005e5$var$visualViewport) window.addEventListener('resize', onResize);
        else $c5fe598a15f005e5$var$visualViewport.addEventListener('resize', onResize);
        return ()=>{
            if (!$c5fe598a15f005e5$var$visualViewport) window.removeEventListener('resize', onResize);
            else $c5fe598a15f005e5$var$visualViewport.removeEventListener('resize', onResize);
        };
    }, []);
    return size1;
}
function $c5fe598a15f005e5$var$getViewportSize() {
    return {
        width: $c5fe598a15f005e5$var$visualViewport?.width || window.innerWidth,
        height: $c5fe598a15f005e5$var$visualViewport?.height || window.innerHeight
    };
}


var $5475261706737633$exports = {};

$parcel$export($5475261706737633$exports, "useDescription", () => $5475261706737633$export$f8aeda7b10753fa1);


let $5475261706737633$var$descriptionId = 0;
const $5475261706737633$var$descriptionNodes = new Map();
function $5475261706737633$export$f8aeda7b10753fa1(description) {
    let [id1, setId] = $gskSG$useState(null);
    $62918828a5c4cefe$export$e5c5a5f917a5871c(()=>{
        if (!description) return;
        let desc = $5475261706737633$var$descriptionNodes.get(description);
        if (!desc) {
            let id = `react-aria-description-${$5475261706737633$var$descriptionId++}`;
            setId(id);
            let node = document.createElement('div');
            node.id = id;
            node.style.display = 'none';
            node.textContent = description;
            document.body.appendChild(node);
            desc = {
                refCount: 0,
                element: node
            };
            $5475261706737633$var$descriptionNodes.set(description, desc);
        } else setId(desc.element.id);
        desc.refCount++;
        return ()=>{
            if (--desc.refCount === 0) {
                desc.element.remove();
                $5475261706737633$var$descriptionNodes.delete(description);
            }
        };
    }, [
        description
    ]);
    return {
        'aria-describedby': description ? id1 : undefined
    };
}


var $43a0edf5ccd884bb$exports = {};

$parcel$export($43a0edf5ccd884bb$exports, "isMac", () => $43a0edf5ccd884bb$export$9ac100e40613ea10);
$parcel$export($43a0edf5ccd884bb$exports, "isIPhone", () => $43a0edf5ccd884bb$export$186c6964ca17d99);
$parcel$export($43a0edf5ccd884bb$exports, "isIPad", () => $43a0edf5ccd884bb$export$7bef049ce92e4224);
$parcel$export($43a0edf5ccd884bb$exports, "isIOS", () => $43a0edf5ccd884bb$export$fedb369cb70207f1);
$parcel$export($43a0edf5ccd884bb$exports, "isAppleDevice", () => $43a0edf5ccd884bb$export$e1865c3bedcd822b);
$parcel$export($43a0edf5ccd884bb$exports, "isWebKit", () => $43a0edf5ccd884bb$export$78551043582a6a98);
$parcel$export($43a0edf5ccd884bb$exports, "isChrome", () => $43a0edf5ccd884bb$export$6446a186d09e379e);
$parcel$export($43a0edf5ccd884bb$exports, "isAndroid", () => $43a0edf5ccd884bb$export$a11b0059900ceec8);
/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ function $43a0edf5ccd884bb$var$testUserAgent(re) {
    return typeof window !== 'undefined' && window.navigator != null ? re.test(window.navigator.userAgent) : false;
}
function $43a0edf5ccd884bb$var$testPlatform(re) {
    return typeof window !== 'undefined' && window.navigator != null ? re.test(window.navigator.platform) : false;
}
function $43a0edf5ccd884bb$export$9ac100e40613ea10() {
    return $43a0edf5ccd884bb$var$testPlatform(/^Mac/);
}
function $43a0edf5ccd884bb$export$186c6964ca17d99() {
    return $43a0edf5ccd884bb$var$testPlatform(/^iPhone/);
}
function $43a0edf5ccd884bb$export$7bef049ce92e4224() {
    return $43a0edf5ccd884bb$var$testPlatform(/^iPad/) || $43a0edf5ccd884bb$export$9ac100e40613ea10() && navigator.maxTouchPoints > 1;
}
function $43a0edf5ccd884bb$export$fedb369cb70207f1() {
    return $43a0edf5ccd884bb$export$186c6964ca17d99() || $43a0edf5ccd884bb$export$7bef049ce92e4224();
}
function $43a0edf5ccd884bb$export$e1865c3bedcd822b() {
    return $43a0edf5ccd884bb$export$9ac100e40613ea10() || $43a0edf5ccd884bb$export$fedb369cb70207f1();
}
function $43a0edf5ccd884bb$export$78551043582a6a98() {
    return $43a0edf5ccd884bb$var$testUserAgent(/AppleWebKit/) && !$43a0edf5ccd884bb$export$6446a186d09e379e();
}
function $43a0edf5ccd884bb$export$6446a186d09e379e() {
    return $43a0edf5ccd884bb$var$testUserAgent(/Chrome/);
}
function $43a0edf5ccd884bb$export$a11b0059900ceec8() {
    return $43a0edf5ccd884bb$var$testUserAgent(/Android/);
}


var $6f85328eaea47571$exports = {};

$parcel$export($6f85328eaea47571$exports, "useEvent", () => $6f85328eaea47571$export$90fc3a17d93f704c);

function $6f85328eaea47571$export$90fc3a17d93f704c(ref, event, handler1, options) {
    let handlerRef = $gskSG$useRef(handler1);
    handlerRef.current = handler1;
    let isDisabled = handler1 == null;
    $gskSG$useEffect(()=>{
        if (isDisabled) return;
        let element = ref.current;
        let handler = (e)=>handlerRef.current.call(this, e)
        ;
        element.addEventListener(event, handler, options);
        return ()=>{
            element.removeEventListener(event, handler, options);
        };
    }, [
        ref,
        event,
        options,
        isDisabled
    ]);
}


var $8bfb318ccfa2e412$exports = {};

$parcel$export($8bfb318ccfa2e412$exports, "useValueEffect", () => $8bfb318ccfa2e412$export$14d238f342723f25);


function $8bfb318ccfa2e412$export$14d238f342723f25(defaultValue) {
    let [value, setValue] = $gskSG$useState(defaultValue);
    let valueRef = $gskSG$useRef(value);
    let effect = $gskSG$useRef(null);
    valueRef.current = value;
    // Store the function in a ref so we can always access the current version
    // which has the proper `value` in scope.
    let nextRef = $gskSG$useRef(null);
    nextRef.current = ()=>{
        // Run the generator to the next yield.
        let newValue = effect.current.next();
        // If the generator is done, reset the effect.
        if (newValue.done) {
            effect.current = null;
            return;
        }
        // If the value is the same as the current value,
        // then continue to the next yield. Otherwise,
        // set the value in state and wait for the next layout effect.
        if (value === newValue.value) nextRef.current();
        else setValue(newValue.value);
    };
    $62918828a5c4cefe$export$e5c5a5f917a5871c(()=>{
        // If there is an effect currently running, continue to the next yield.
        if (effect.current) nextRef.current();
    });
    let queue = $gskSG$useCallback((fn)=>{
        effect.current = fn(valueRef.current);
        nextRef.current();
    }, [
        effect,
        nextRef
    ]);
    return [
        value,
        queue
    ];
}


var $7b1a72e750057d55$exports = {};

$parcel$export($7b1a72e750057d55$exports, "scrollIntoView", () => $7b1a72e750057d55$export$53a0910f038337bd);
function $7b1a72e750057d55$export$53a0910f038337bd(scrollView, element) {
    let offsetX = $7b1a72e750057d55$var$relativeOffset(scrollView, element, 'left');
    let offsetY = $7b1a72e750057d55$var$relativeOffset(scrollView, element, 'top');
    let width = element.offsetWidth;
    let height = element.offsetHeight;
    let x = scrollView.scrollLeft;
    let y = scrollView.scrollTop;
    let maxX = x + scrollView.offsetWidth;
    let maxY = y + scrollView.offsetHeight;
    if (offsetX <= x) x = offsetX;
    else if (offsetX + width > maxX) x += offsetX + width - maxX;
    if (offsetY <= y) y = offsetY;
    else if (offsetY + height > maxY) y += offsetY + height - maxY;
    scrollView.scrollLeft = x;
    scrollView.scrollTop = y;
}
/**
 * Computes the offset left or top from child to ancestor by accumulating
 * offsetLeft or offsetTop through intervening offsetParents.
 */ function $7b1a72e750057d55$var$relativeOffset(ancestor, child, axis) {
    const prop = axis === 'left' ? 'offsetLeft' : 'offsetTop';
    let sum = 0;
    while(child.offsetParent){
        sum += child[prop];
        if (child.offsetParent === ancestor) break;
        else if (child.offsetParent.contains(ancestor)) {
            // If the ancestor is not `position:relative`, then we stop at
            // _its_ offset parent, and we subtract off _its_ offset, so that
            // we end up with the proper offset from child to ancestor.
            sum -= ancestor[prop];
            break;
        }
        child = child.offsetParent;
    }
    return sum;
}




export {$4208ab27be92763a$export$f680877a34711e37 as useId, $4208ab27be92763a$export$cd8c9cb68f842629 as mergeIds, $4208ab27be92763a$export$b4cc09c592e8fdb8 as useSlotId, $2aefb161b9a41928$export$e08e3b67e392101e as chain, $699afe8e9e0f66de$export$9d1611c77c2fe928 as mergeProps, $7efcb978e02fb174$export$457c3d6518dd4c6f as filterDOMProps, $0172e2a3384c2851$export$de79e2c695e052f3 as focusWithoutScrolling, $5062b1512bdf762b$export$622cea445a1c5b7d as getOffset, $5cdbf4ddafd135bc$re_export$clamp as clamp, $5cdbf4ddafd135bc$re_export$snapValueToStep as snapValueToStep, $fdecdd2f4116564c$export$24490316f764c430 as runAfterTransition, $95a0e07fe544f4e9$export$7bbed75feba39706 as useDrag1D, $042598a43c3fee40$export$4eaf04e54aa8eed6 as useGlobalListeners, $2ab91c20d1fbac23$export$d6875122194c7b44 as useLabels, $1ea3613dec903cb9$export$4338b53315abf666 as useObjectRef, $d3ab8ae13db3a1fd$export$496315a1608d9602 as useUpdateEffect, $62918828a5c4cefe$export$e5c5a5f917a5871c as useLayoutEffect, $f3e728a941364b05$export$683480f191c0e3ea as useResizeObserver, $518b8f251641d71b$export$4debdb1a3f0fa79e as useSyncRef, $2fe8625dffd76a00$export$cfa2225e87938781 as getScrollParent, $c5fe598a15f005e5$export$d699905dd57c73ca as useViewportSize, $5475261706737633$export$f8aeda7b10753fa1 as useDescription, $43a0edf5ccd884bb$export$9ac100e40613ea10 as isMac, $43a0edf5ccd884bb$export$186c6964ca17d99 as isIPhone, $43a0edf5ccd884bb$export$7bef049ce92e4224 as isIPad, $43a0edf5ccd884bb$export$fedb369cb70207f1 as isIOS, $43a0edf5ccd884bb$export$e1865c3bedcd822b as isAppleDevice, $43a0edf5ccd884bb$export$78551043582a6a98 as isWebKit, $43a0edf5ccd884bb$export$6446a186d09e379e as isChrome, $43a0edf5ccd884bb$export$a11b0059900ceec8 as isAndroid, $6f85328eaea47571$export$90fc3a17d93f704c as useEvent, $8bfb318ccfa2e412$export$14d238f342723f25 as useValueEffect, $7b1a72e750057d55$export$53a0910f038337bd as scrollIntoView};
//# sourceMappingURL=module.js.map
