var $aJbEv$reactariautils = require("@react-aria/utils");

function $parcel$exportWildcard(dest, source) {
  Object.keys(source).forEach(function(key) {
    if (key === 'default' || key === '__esModule' || dest.hasOwnProperty(key)) {
      return;
    }

    Object.defineProperty(dest, key, {
      enumerable: true,
      get: function get() {
        return source[key];
      }
    });
  });

  return dest;
}
function $parcel$export(e, n, v, s) {
  Object.defineProperty(e, n, {get: v, set: s, enumerable: true, configurable: true});
}
var $aac2cbf1da32ab7a$exports = {};

$parcel$export($aac2cbf1da32ab7a$exports, "useField", () => $aac2cbf1da32ab7a$export$294aa081a6c6f55d);
var $773550019cadc987$exports = {};

$parcel$export($773550019cadc987$exports, "useLabel", () => $773550019cadc987$export$8467354a121f1b9f);

function $773550019cadc987$export$8467354a121f1b9f(props) {
    let { id: id , label: label , 'aria-labelledby': ariaLabelledby , 'aria-label': ariaLabel , labelElementType: labelElementType = 'label'  } = props;
    id = $aJbEv$reactariautils.useId(id);
    let labelId = $aJbEv$reactariautils.useId();
    let labelProps = {
    };
    if (label) {
        ariaLabelledby = ariaLabelledby ? `${ariaLabelledby} ${labelId}` : labelId;
        labelProps = {
            id: labelId,
            htmlFor: labelElementType === 'label' ? id : undefined
        };
    } else if (!ariaLabelledby && !ariaLabel) console.warn('If you do not provide a visible label, you must specify an aria-label or aria-labelledby attribute for accessibility');
    let fieldProps = $aJbEv$reactariautils.useLabels({
        id: id,
        'aria-label': ariaLabel,
        'aria-labelledby': ariaLabelledby
    });
    return {
        labelProps: labelProps,
        fieldProps: fieldProps
    };
}



function $aac2cbf1da32ab7a$export$294aa081a6c6f55d(props) {
    let { description: description , errorMessage: errorMessage , validationState: validationState  } = props;
    let { labelProps: labelProps , fieldProps: fieldProps  } = $773550019cadc987$export$8467354a121f1b9f(props);
    let descriptionId = $aJbEv$reactariautils.useSlotId([
        Boolean(description),
        Boolean(errorMessage),
        validationState
    ]);
    let errorMessageId = $aJbEv$reactariautils.useSlotId([
        Boolean(description),
        Boolean(errorMessage),
        validationState
    ]);
    fieldProps = $aJbEv$reactariautils.mergeProps(fieldProps, {
        'aria-describedby': [
            descriptionId,
            // Use aria-describedby for error message because aria-errormessage is unsupported using VoiceOver or NVDA. See https://github.com/adobe/react-spectrum/issues/1346#issuecomment-740136268
            errorMessageId,
            props['aria-describedby']
        ].filter(Boolean).join(' ') || undefined
    });
    return {
        labelProps: labelProps,
        fieldProps: fieldProps,
        descriptionProps: {
            id: descriptionId
        },
        errorMessageProps: {
            id: errorMessageId
        }
    };
}



$parcel$exportWildcard(module.exports, $aac2cbf1da32ab7a$exports);
$parcel$exportWildcard(module.exports, $773550019cadc987$exports);


//# sourceMappingURL=main.js.map
